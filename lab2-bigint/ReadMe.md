# Алгоритмы для работы с большими числами (BigInt)

В данном документе представлены алгоритмы для работы с большими целыми числами, которые реализуют основные операции: сложение, вычитание, умножение и деление. Все операции реализованы с использованием класса `BigInt` для работы с числами произвольной длины.

## 1. Сложение

### Алгоритм: Поразрядное сложение с учетом переноса (Carry Addition)
Этот алгоритм является классическим методом сложения чисел, который используется при сложении чисел произвольной длины. Процесс заключается в поразрядном сложении, где каждый разряд складывается отдельно, с учетом переноса, если сумма разрядов больше 9.

### Шаги:
1. Начинаем с младших разрядов и складываем цифры по разрядам.
2. Если сумма цифр больше 9, переносим единицу в следующий разряд.
3. Повторяем процесс для всех разрядов.
4. Если в конце остается перенос, добавляем новый разряд.

### Реализация:
```python
def __add__(self, other):
    if self.sign == other.sign:
        result = BigInt()
        result.sign = self.sign
        carry = 0

        max_len = max(len(self.digits), len(other.digits))
        for i in range(max_len):
            sum_digits = carry
            if i < len(self.digits):
                sum_digits += self.digits[i]
            if i < len(other.digits):
                sum_digits += other.digits[i]

            carry = sum_digits // 10
            result.digits.append(sum_digits % 10)

        if carry:
            result.digits.append(carry)

        result._normalize()
        return result
    else:
        return self - (-other)
```
## 2. Вычитание
### Алгоритм: Поразрядное вычитание с учетом заимствования (Borrowing Subtraction)
Вычитание чисел аналогично поразрядному сложению, но с учетом заимствования. Если цифра в вычитаемом числе больше цифры в числе, из которого вычитаем, происходит заимствование из следующего разряда.

### Шаги:
1. Начинаем с младших разрядов и вычитаем цифры.
2. Если цифра вычитаемого числа больше, чем цифра в числе, из которого вычитаем, происходит заимствование.
3. Повторяем процесс для всех разрядов.
Реализация:
```python
def __sub__(self, other):
    if self.sign != other.sign:
        return self + (-other)
    if abs(self) >= abs(other):
        result = BigInt()
        result.sign = self.sign
        borrow = 0

        for i in range(len(self.digits)):
            diff_digits = self.digits[i] - borrow
            if i < len(other.digits):
                diff_digits -= other.digits[i]

            if diff_digits < 0:
                diff_digits += 10
                borrow = 1
            else:
                borrow = 0

            result.digits.append(diff_digits)

        result._normalize()
        return result
    else:
        return -(other - self)

```


## 3. Умножение
### Алгоритм: Наивное умножение (Naive Multiplication)
Этот алгоритм является наивным методом умножения, аналогичным поразрядному умножению. Мы умножаем каждую цифру одного числа на каждую цифру другого числа, с учетом переноса.

### Шаги:
1. Умножаем каждую цифру одного числа на каждую цифру другого числа.
2. Суммируем результаты по разрядам и учитываем перенос.
3. Если перенос выходит за пределы разряда, переносим его в следующий разряд.
Реализация:
```python
def _naive_multiply(self, other):
    result = BigInt("0")
    result.digits = [0] * (len(self.digits) + len(other.digits))

    for i in range(len(self.digits)):
        for j in range(len(other.digits)):
            result.digits[i + j] += self.digits[i] * other.digits[j]
            result.digits[i + j + 1] += result.digits[i + j] // 10
            result.digits[i + j] %= 10

    result._normalize()
    return result

```

## 4 Умножение с использованием Toom-Cook (Toom-3)
### Алгоритм: Toom-Cook (Toom-3)
Toom-Cook — это алгоритм умножения чисел произвольной длины, который использует метод разделяй и властвуй. В частности, Toom-3 делит каждое число на три части и применяет рекурсивное умножение для этих частей, а затем комбинирует результаты с помощью интерполяции.

### Шаги:
1. Разделяем каждое число на три части:

$$A = A_2 * 10^2k + A_1 * 10^k + A_0$$

2. Выполняем умножение для каждого из тройных произведений: 
$P_0 = A_0 * B_0, P_1=(A_0+A_1)$

## 5 Деление Naive
### Алгоритм: Деление с использованием длинного деления (Long Division)
Этот алгоритм деления выполняется аналогично школьному методу деления. Мы поочередно берем цифры делимого и делим их на делитель, учитывая остаток и вычисляя частное.

### Шаги:
1. Перебираем цифры делимого и добавляем их к текущему остатку.
2. Для каждого остатка вычисляем, сколько раз делитель помещается в этот остаток.
3. Переходим к следующей цифре делимого и повторяем процесс.

